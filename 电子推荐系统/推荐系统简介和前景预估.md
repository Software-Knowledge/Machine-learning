推荐系统简介和前景预估
---

# 1. 推荐系统主要业务流程
1. 按照循环进行推荐

## 1.1. 数据收集
1. 首先要收集到很多的有价值的用户行为数据
2. 数据一定要足够多并且有效

## 1.2. ETL
1. ETL模块的主要目的是从收集到的原始数据中提取关键字段，将数据转化为结构化的数据存储到数据仓库中。
2. 按照一定的规则或策略过滤掉脏数据。
3. 用户量和数据量特别大的时候，我们一般采用HDFS、Hive、HBase等大数据分布式存储系统来存储数据。

## 1.3. 特征工程
1. 不是所有的推荐算法都需要特征工程的。
2. 按需使用

## 1.4. 推荐算法
1. 是推荐系统的核心之一。
2. 一般设计到模型训练、预测两个核心操作。

## 1.5. 推荐结果存储模块
1. Mysql可以承受小量级的数据，但是数据量变大之后，每天更新用户推荐时，都需要先找到用户存储的位置再进行推荐。
2. 用户规模大，高并发读写，大数量存储时，采用CouchBase、Redis等可以横向扩容的数据库。我们一般采用Nosql数据库来存储，并且要求数据库可扩展。
3. 最好的方法:通过一个数据管道(如Kafka)解耦。

## 1.6. 提供web服务
1. 该模块是系统直接服务用户的模块，要支持高并发访问、水平可扩展、亚秒级响应延时

# 2. 推荐系统支撑模块

## 2.1. 评估模块
1. 推荐评估模块的主要作用是评估整个推荐系统的质量及价值产出。一般来说可以从两个维度来评估。

### 2.1.1. 离线评估
1. 主要是评估训练好的推荐模型的"质量"，模型在上线服务之前需要评估该模型的准确度，一般是将训练数据分为训练集和测试集，训练集用于训练模型，而测试集用来评估模型的预测误差。

### 2.1.2. 在线评估
1. 模型上线提供推荐服务过程中来评估一些真实的转化指标，比如转化率、购买率、点击率、播放时长等。线上评估一般会结合AB测试，先放一部分量，如果效果达到期望再逐步拓展到所有用户，避免模型线上效果不好严重影响用户体验和收益指标等。

## 2.2. 调度模块
1. 需要用有向图的依赖关系依次执行每个任务，这些任务的依赖关系需要借助合适的调度系统(如Azkaban)来实现。

## 2.3. 监控模块
1. 监控模块解决的是当推荐业务(依赖的)任务由于各种原因调度失败时可以及时告警。

## 2.4. 审查模块
1. 对于推荐系统结果数据格式的正确性、有效性进行检查。

# 3. 推荐系统范式
1. 目的:为用户推荐可能喜欢的物品，涉及到用户和物体。

## 3.1. 范式一:完全个性化范式：
1. 为每个用户提供个性化的内容，每个用户推荐结果都不同

## 3.2. 范式二：群组个性化范式
1. 首先将用户分组(根据用户的兴趣，将兴趣相似的归为一组)，每组用户提供一个个性化的推荐列表，同一组的用户推荐列表一样，不同组的用户推荐列表不一样；

## 3.3. 范式三:非个性化范式
1. 为所有用户提供完全一样的推荐；
2. 可以方便用户发现新热内容，也可以作为冷启动的默认推荐。

## 3.4. 范式四:标记物关联标记物的范式
1. 为每个标记物关联一组标记物，作为用户在访问标记物详情页时的推荐，每个用户都是相同的标记物；

## 3.5. 范式五:笛卡尔积范式
1. 每个用户跟每个标记物的组合产生的推荐都不相同，不同用户在同一个页面看到的推荐结果都不一样；

# 4. 推荐系统架构设计
1. 个人开发在ETL、算法训练，预测到插入数据库独立导致的低效率。
2. 为了支撑更多类型的推荐业务，减少系统的耦合，便于发现和追踪问题，节省人力成本，方便算法快速上线和迭代，需要设计比较好的推荐系统架构，而好的推荐系统架构应该具备6大原则：通用性，模块化，组件化，一致性，可拓展性，抽象性。
    1. 通用性：所谓通用，就是该架构具备包容的能力，业务上的任何推荐产品都可以用这一套架构来涵盖和实现。
    2. 模块化：模块化的目的在于将一个业务按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过一致性的协议调用。将一个大的系统模块化之后，每个模块都可以被高度复用。模块化的目的是为了重用，模块化后可以方便重复使用和插拨到不同平台，不同推荐业务逻辑中。
    3. 组件化：组件化就是基于可重用的目的，将一个大的软件系统拆分成多个独立的组件，主要目的就是减少耦合。一个独立的组件可以是一个软件包、web服务、web资源或者是封装了一些函数的模块。这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件。组件化的目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护，组件可插拔，通过组件的拼接和增减提供更丰富的能力。
    4. 组件化和模块化比较类似，目标分别是为了更好的解耦和重用，就像搭积木一样构建复杂系统。
    5. 一致性：指模块的数据输入输出采用统一的数据交互协议，做到整个系统一致。
    6. 可拓展性：系统具备支撑大数据量，大并发的能力，并且容易在该系统中增添新的模块，提供更丰富的能力，让业务更加完备自治。
    7. 抽象性：将相似的操作和流程抽象为统一的操作，主要目的是简化系统设计，让系统更加简洁通用。针对推荐系统采用数学上的概念抽象如下：比如把算子和业务进行抽象

## 4.1. 基础组件
1. 业务枚举类型、常量、路径处理、配置文件解析等。

## 4.2. 数据读入组件
1. 包括从HDFS、数据仓库、HBase、Mysql等相关数据库读取数据的操作，将这些操作封装成通用操作，方便所有业务线统一调用

## 4.3. 数据流出组件
1. 类似数据读入组件，将推荐结果插入最终存储(如Redis，CouchBase等)的操作封装成算子，我们一般是将推荐结果流入Kafka，利用Kafka作为数据管道，最终再从Kafka将数据插入推荐存储服务器；

## 4.4. 算法组件
1. 这个是整个推荐系统的核心。在工程实现过程中，我们将推荐系统中涉及到的算子抽象为3个接口， AlgParameters(算子依赖的参数集合)、 Algorithm/AlgorithmEx (具体的算法实现，如果算法依赖模型，采用AlgorithmEx，比如利用模型做推断)、Model(算法训练后的模型，包括模型的导入、导出等接口)。所有的算子实现实现上面3个接口的抽象方法。下图给出了这3个接口包含的具体方法以及Spark mllib中的矩阵分解基于该抽象的实现。

# 5. 推荐系统工程实现的设计哲学

## 5.1. 好的推荐系统工程实现
1. 别人很容易理解你的逻辑；
2. 按照业务流/数据流来组织代码结构；
3. 便于debug；
4. 保证数据存储、代码模块、业务逻辑的一致性；

## 5.2. 好的推荐系统工程架构的原则
1. 尽量将逻辑拆解为独立的小单元；
2. 代码单元的输入输出定义清晰；
3. 设置合适的交互出入口；
4. 确定通用一致的数据交互格式；
5. 数据存储、业务功能点、代码单元保持一一对应；

## 5.3. 如何进行设计系统架构
1. 确定思考问题的主线：数据流or 业务流；
2. 画出业务流或者数据流的架构图；
3. 确定核心功能模块；
4. 根据核心功能模块组织代码目录结构，数据存储结构；
5. 定义清晰明确的数据格式；

# 6. 推荐系统业务落地需要关注的点

## 6.1. 二八原则
1. 你的产品可能包含很多推荐模块，但是在投入精力迭代优化过程中，需要将核心精力放到用户触点多的产品(位置好，更容易曝光给用户的推荐产品)上，因为这些产品形态占整个推荐价值产出的绝大部分。这个道理看起来谁都懂，但在实际工作中一直坚守这个原则，还是很难的；

## 6.2. 牛逼的算法与工程可实现性易用性之间的平衡
1. 好的推荐算法一定要是易于工程实现，跟公司当前的技术架构、人员能力、可用资源是匹配的；

## 6.3. 推荐系统冷启动

## 6.4. 推荐系统的解释

## 6.5. 推荐系统UI设计和交互逻辑

# 7. 参考
1. <a href = "https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247503440&idx=5&sn=307dff107219d9435c97853a417878fd&chksm=e99efda9dee974bf7f0a6ad8aa9b44012ae5e6978333862f0a52fe16264701e82800785598ad&scene=21#wechat_redirect">等待再次阅读，关于框架问题</a>